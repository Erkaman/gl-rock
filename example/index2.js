

var mat4 = require('gl-mat4');
var vec3 = require('gl-vec3');
var glShader = require('gl-shader');
var glslify = require('glslify');
var shell = require("gl-now")();
var randomItem = require('random-item');
var createMovableCamera = require('gl-movable-camera');
var createPlane = require('primitive-plane');
var createNormals = require('normals');
var Geometry = require('gl-geometry');
var arrayShuffle = require('array-shuffle');
var geoTransform = require('geo-3d-transform-mat4');
var Work = require('webworkify');
var randomArray = require('random-array');

var RockObj = require('./rock_obj.js');

var createRock = require('./rock.js').createRock;
var buildRockMesh = require('./rock.js').buildRockMesh;
var drawRock = require('./rock.js').drawRock;
var isRockMeshBuilt = require('./rock.js').isRockMeshBuilt;

var rockShader, planeShader;

var bg = [0.6, 0.7, 1.0]; // clear color.

var ROCK_W = 100;
var ROCK_H = 10;
var ROCK_SPACING = 4;

var rocks;
var planeGeo;

var camera = createMovableCamera({
    position: vec3.fromValues(-5.0, 6.0, 0.0),
    viewDir: vec3.fromValues(1.0, -0.3, 0)
});

var workers;
var NUM_WORKERS = 3;

shell.on("gl-init", function () {
    var gl = shell.gl

    gl.enable(gl.DEPTH_TEST);
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);

    rocks = [];

    /*
    The rocks are generated by web workers.
     */

    workers = new Array(NUM_WORKERS);
    for(var workerI = 0; workerI < NUM_WORKERS; ++workerI) {

        workers[workerI] = Work(require('./worker.js'));

        workers[workerI].addEventListener('message', function (msg) {
            /*
            If we have not generated enough rocks, tell worker to generate another one.
             */

            if (rocks.length >= (ROCK_W * ROCK_H)) {
                workers[msg.data[0]].terminate();
        //        console.log("done working for worker ", msg.data[0]);
            }

            var rock = msg.data[1];

            rocks.push(rock);

            workers[msg.data[0]].postMessage(msg.data[0]);

        });

        // start worker. We send worker id to worker.
        workers[workerI].postMessage(workerI);

    }


    /*
    Create Plane geometry.
     */

    planeGeo = createPlane(1, 1);

    var model = mat4.create();
    mat4.rotateX(model, model, Math.PI / 2);
    mat4.translate(model, model, [0, 0.0, 0.9]);
    mat4.scale(model, model, [1000, 1000, 1]);
    planeGeo.positions = geoTransform(planeGeo.positions, model);

    planeGeo = Geometry(gl)
        .attr('aPosition', planeGeo.positions)
        .attr('aNormal', createNormals.vertexNormals(planeGeo.cells, planeGeo.positions))
        .faces(planeGeo.cells);


    /*
    Load Shaders
     */

    rockShader = glShader(gl, glslify("./rock_vert.glsl"), glslify("./rock_frag.glsl"));
    planeShader = glShader(gl, glslify("./plane_vert.glsl"), glslify("./plane_frag.glsl"));

});

shell.on("gl-render", function (t) {
    var gl = shell.gl
    var canvas = shell.canvas;

    gl.clearColor(bg[0], bg[1], bg[2], 1);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
    gl.viewport(0, 0, canvas.width, canvas.height);

    var model = mat4.create();
    var projection = mat4.create();
    var scratchMat = mat4.create();
    var view = camera.view();
    var scratchVec = vec3.create();

    mat4.perspective(projection, Math.PI / 2, canvas.width / canvas.height, 0.1, 10000.0);

    rockShader.bind();

    for(var i = 0; i < rocks.length; ++i) {


        var w = Math.floor(i / ROCK_H);
        var h = Math.floor(i % ROCK_H);

        var translation = [(w) * ROCK_SPACING, 0.0, (h - ROCK_H / 2.0) * ROCK_SPACING];
        
        var rock = rocks[w * ROCK_H +h];
        
        // build rock mesh on the fly. 
        if(!isRockMeshBuilt(rock)) {
            buildRockMesh(gl, rock);
        }

        drawRock(rockShader, view, projection, true, translation, rock);
    }




    planeShader.bind();

    planeShader.uniforms.uView = view;
    planeShader.uniforms.uProjection = projection;

    // draw plane double-sided
    planeGeo.bind(planeShader);
    gl.disable(gl.CULL_FACE);
    planeGeo.draw();
    gl.enable(gl.CULL_FACE);
    planeGeo.unbind();



});

var freeCamera = false;

shell.on("tick", function () {
    var gl = shell.gl


    if(!freeCamera) {

        // if not free camera, make the camera traverse a set path.

        camera.position[0] += 0.1;

    } else {
        // if free camera, listen to keyboard and mouse input.

        if (shell.wasDown("mouse-left")) {

            camera.turn(-(shell.mouseX - shell.prevMouseX), +(shell.mouseY - shell.prevMouseY));
        }

        if (shell.wasDown("W")) {
            camera.walk(true);
        } else if (shell.wasDown("S")) {
            camera.walk(false);
        }

        if (shell.wasDown("A")) {
            camera.stride(true);
        } else if (shell.wasDown("D")) {
            camera.stride(false);
        }

        if (shell.wasDown("O")) {
            camera.fly(true);
        } else if (shell.wasDown("L")) {
            camera.fly(false);
        }

        if (shell.wasDown("M")) {
            camera.velocity = 0.3;
        } else {
            camera.velocity = 0.05;
        }
    }

    if (shell.wasDown("mouse-left")) {
        // press left mouse button to free the camera.
        freeCamera = true
    }
});